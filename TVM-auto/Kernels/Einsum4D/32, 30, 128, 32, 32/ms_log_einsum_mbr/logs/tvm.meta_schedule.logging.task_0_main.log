2025-07-03 10:24:07 [INFO] [task_scheduler.cc:166] Initializing Task #0: "main"
2025-07-03 10:24:07 [INFO] [task_scheduler.cc:41] 
# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(G: T.Buffer((128, 32, 32, 32), "float32"), X: T.Buffer((30, 32, 32), "float32"), Y: T.Buffer((32, 30, 128), "float32")):
        T.func_attr({"tir.noalias": True})
        # with T.block("root"):
        for mm, bb, rr, rn, rk in T.grid(32, 30, 128, 32, 32):
            with T.block("Y"):
                v_mm, v_bb, v_rr, v_rn, v_rk = T.axis.remap("SSSRR", [mm, bb, rr, rn, rk])
                T.reads(G[v_rr, v_rn, v_mm, v_rk], X[v_bb, v_rn, v_rk])
                T.writes(Y[v_mm, v_bb, v_rr])
                with T.init():
                    Y[v_mm, v_bb, v_rr] = T.float32(0.0)
                Y[v_mm, v_bb, v_rr] = Y[v_mm, v_bb, v_rr] + G[v_rr, v_rn, v_mm, v_rk] * X[v_bb, v_rn, v_rk]
2025-07-03 10:24:07 [INFO] [multi_level_tiling_with_intrin.cc:52] The workload cannot be tensorized.
2025-07-03 10:24:07 [INFO] [multi_level_tiling_with_intrin.cc:52] The workload cannot be tensorized.
2025-07-03 10:24:07 [INFO] [task_scheduler.cc:170] Total 3 design space(s) generated
2025-07-03 10:24:07 [INFO] [task_scheduler.cc:176] Design space #0:
# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(G: T.Buffer((128, 32, 32, 32), "float32"), X: T.Buffer((30, 32, 32), "float32"), Y: T.Buffer((32, 30, 128), "float32")):
        T.func_attr({"tir.noalias": True})
        with T.block("root"):
            T.reads()
            T.writes()
            T.block_attr({"meta_schedule.parallel": 64, "meta_schedule.unroll_explicit": 64, "meta_schedule.vectorize": 64})
            Y_global = T.alloc_buffer((32, 30, 128))
            for mm_0, bb_0, rr_0, mm_1, bb_1, rr_1 in T.grid(2, 10, 8, 1, 3, 4):
                for rn_0, rk_0, mm_2, bb_2, rr_2, rn_1, rk_1, mm_3, bb_3, rr_3 in T.grid(32, 32, 2, 1, 1, 1, 1, 8, 1, 4):
                    with T.block("Y"):
                        v_mm = T.axis.spatial(32, mm_0 * 16 + mm_1 * 16 + mm_2 * 8 + mm_3)
                        v_bb = T.axis.spatial(30, bb_0 * 3 + bb_1 + bb_2 + bb_3)
                        v_rr = T.axis.spatial(128, rr_0 * 16 + rr_1 * 4 + rr_2 * 4 + rr_3)
                        v_rn = T.axis.reduce(32, rn_0 + rn_1)
                        v_rk = T.axis.reduce(32, rk_0 + rk_1)
                        T.reads(G[v_rr, v_rn, v_mm, v_rk], X[v_bb, v_rn, v_rk])
                        T.writes(Y_global[v_mm, v_bb, v_rr])
                        T.block_attr({"meta_schedule.tiling_structure": "SSRSRS"})
                        with T.init():
                            Y_global[v_mm, v_bb, v_rr] = T.float32(0.0)
                        Y_global[v_mm, v_bb, v_rr] = Y_global[v_mm, v_bb, v_rr] + G[v_rr, v_rn, v_mm, v_rk] * X[v_bb, v_rn, v_rk]
                for ax0, ax1, ax2 in T.grid(16, 1, 4):
                    with T.block("Y_global"):
                        v0 = T.axis.spatial(32, mm_0 * 16 + ax0)
                        v1 = T.axis.spatial(30, bb_0 * 3 + bb_1 + ax1)
                        v2 = T.axis.spatial(128, rr_0 * 16 + rr_1 * 4 + ax2)
                        T.reads(Y_global[v0, v1, v2])
                        T.writes(Y[v0, v1, v2])
                        Y[v0, v1, v2] = Y_global[v0, v1, v2]
b0 = sch.get_block(name="Y", func_name="main")
b1 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b0, ann_key="meta_schedule.tiling_structure", ann_val="SSRSRS")
l2, l3, l4, l5, l6 = sch.get_loops(block=b0)
v7, v8, v9, v10 = sch.sample_perfect_tile(loop=l2, n=4, max_innermost_factor=64, decision=[2, 1, 2, 8])
l11, l12, l13, l14 = sch.split(loop=l2, factors=[v7, v8, v9, v10], preserve_unit_iters=True, disable_predication=False)
v15, v16, v17, v18 = sch.sample_perfect_tile(loop=l3, n=4, max_innermost_factor=64, decision=[10, 3, 1, 1])
l19, l20, l21, l22 = sch.split(loop=l3, factors=[v15, v16, v17, v18], preserve_unit_iters=True, disable_predication=False)
v23, v24, v25, v26 = sch.sample_perfect_tile(loop=l4, n=4, max_innermost_factor=64, decision=[8, 4, 1, 4])
l27, l28, l29, l30 = sch.split(loop=l4, factors=[v23, v24, v25, v26], preserve_unit_iters=True, disable_predication=False)
v31, v32 = sch.sample_perfect_tile(loop=l5, n=2, max_innermost_factor=64, decision=[32, 1])
l33, l34 = sch.split(loop=l5, factors=[v31, v32], preserve_unit_iters=True, disable_predication=False)
v35, v36 = sch.sample_perfect_tile(loop=l6, n=2, max_innermost_factor=64, decision=[32, 1])
l37, l38 = sch.split(loop=l6, factors=[v35, v36], preserve_unit_iters=True, disable_predication=False)
sch.reorder(l11, l19, l27, l12, l20, l28, l33, l37, l13, l21, l29, l34, l38, l14, l22, l30)
b39 = sch.cache_write(block=b0, write_buffer_index=0, storage_scope="global")
sch.reverse_compute_at(block=b39, loop=l28, preserve_unit_loops=True, index=-1)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.parallel", ann_val=64)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.vectorize", ann_val=64)
v40 = sch.sample_categorical(candidates=[0, 16, 64, 512], probs=[0.25, 0.25, 0.25, 0.25], decision=2)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.unroll_explicit", ann_val=v40)
2025-07-03 10:24:07 [INFO] [task_scheduler.cc:176] Design space #1:
# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(G: T.Buffer((128, 32, 32, 32), "float32"), X: T.Buffer((30, 32, 32), "float32"), Y: T.Buffer((32, 30, 128), "float32")):
        T.func_attr({"tir.noalias": True})
        with T.block("root"):
            T.reads()
            T.writes()
            T.block_attr({"meta_schedule.parallel": 64, "meta_schedule.unroll_explicit": 512, "meta_schedule.vectorize": 64})
            Y_global = T.alloc_buffer((32, 30, 128))
            for mm_0, bb_0, rr_0 in T.grid(2, 10, 8):
                for mm_1, bb_1, rr_1, rn_0, rk_0, mm_2, bb_2, rr_2, rn_1, rk_1, mm_3, bb_3, rr_3 in T.grid(1, 3, 4, 32, 32, 2, 1, 1, 1, 1, 8, 1, 4):
                    with T.block("Y"):
                        v_mm = T.axis.spatial(32, mm_0 * 16 + mm_1 * 16 + mm_2 * 8 + mm_3)
                        v_bb = T.axis.spatial(30, bb_0 * 3 + bb_1 + bb_2 + bb_3)
                        v_rr = T.axis.spatial(128, rr_0 * 16 + rr_1 * 4 + rr_2 * 4 + rr_3)
                        v_rn = T.axis.reduce(32, rn_0 + rn_1)
                        v_rk = T.axis.reduce(32, rk_0 + rk_1)
                        T.reads(G[v_rr, v_rn, v_mm, v_rk], X[v_bb, v_rn, v_rk])
                        T.writes(Y_global[v_mm, v_bb, v_rr])
                        T.block_attr({"meta_schedule.tiling_structure": "SSRSRS"})
                        with T.init():
                            Y_global[v_mm, v_bb, v_rr] = T.float32(0.0)
                        Y_global[v_mm, v_bb, v_rr] = Y_global[v_mm, v_bb, v_rr] + G[v_rr, v_rn, v_mm, v_rk] * X[v_bb, v_rn, v_rk]
                for ax0, ax1, ax2 in T.grid(16, 3, 16):
                    with T.block("Y_global"):
                        v0 = T.axis.spatial(32, mm_0 * 16 + ax0)
                        v1 = T.axis.spatial(30, bb_0 * 3 + ax1)
                        v2 = T.axis.spatial(128, rr_0 * 16 + ax2)
                        T.reads(Y_global[v0, v1, v2])
                        T.writes(Y[v0, v1, v2])
                        Y[v0, v1, v2] = Y_global[v0, v1, v2]
b0 = sch.get_block(name="Y", func_name="main")
b1 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b0, ann_key="meta_schedule.tiling_structure", ann_val="SSRSRS")
l2, l3, l4, l5, l6 = sch.get_loops(block=b0)
v7, v8, v9, v10 = sch.sample_perfect_tile(loop=l2, n=4, max_innermost_factor=64, decision=[2, 1, 2, 8])
l11, l12, l13, l14 = sch.split(loop=l2, factors=[v7, v8, v9, v10], preserve_unit_iters=True, disable_predication=False)
v15, v16, v17, v18 = sch.sample_perfect_tile(loop=l3, n=4, max_innermost_factor=64, decision=[10, 3, 1, 1])
l19, l20, l21, l22 = sch.split(loop=l3, factors=[v15, v16, v17, v18], preserve_unit_iters=True, disable_predication=False)
v23, v24, v25, v26 = sch.sample_perfect_tile(loop=l4, n=4, max_innermost_factor=64, decision=[8, 4, 1, 4])
l27, l28, l29, l30 = sch.split(loop=l4, factors=[v23, v24, v25, v26], preserve_unit_iters=True, disable_predication=False)
v31, v32 = sch.sample_perfect_tile(loop=l5, n=2, max_innermost_factor=64, decision=[32, 1])
l33, l34 = sch.split(loop=l5, factors=[v31, v32], preserve_unit_iters=True, disable_predication=False)
v35, v36 = sch.sample_perfect_tile(loop=l6, n=2, max_innermost_factor=64, decision=[32, 1])
l37, l38 = sch.split(loop=l6, factors=[v35, v36], preserve_unit_iters=True, disable_predication=False)
sch.reorder(l11, l19, l27, l12, l20, l28, l33, l37, l13, l21, l29, l34, l38, l14, l22, l30)
b39 = sch.cache_write(block=b0, write_buffer_index=0, storage_scope="global")
sch.reverse_compute_at(block=b39, loop=l27, preserve_unit_loops=True, index=-1)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.parallel", ann_val=64)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.vectorize", ann_val=64)
v40 = sch.sample_categorical(candidates=[0, 16, 64, 512], probs=[0.25, 0.25, 0.25, 0.25], decision=3)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.unroll_explicit", ann_val=v40)
2025-07-03 10:24:07 [INFO] [task_scheduler.cc:176] Design space #2:
# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def main(G: T.Buffer((128, 32, 32, 32), "float32"), X: T.Buffer((30, 32, 32), "float32"), Y: T.Buffer((32, 30, 128), "float32")):
        T.func_attr({"tir.noalias": True})
        with T.block("root"):
            T.reads()
            T.writes()
            T.block_attr({"meta_schedule.parallel": 64, "meta_schedule.unroll_explicit": 16, "meta_schedule.vectorize": 64})
            for mm_0, bb_0, rr_0, mm_1, bb_1, rr_1, rn_0, rk_0, mm_2, bb_2, rr_2, rn_1, rk_1, mm_3, bb_3, rr_3 in T.grid(2, 10, 8, 1, 3, 4, 32, 32, 2, 1, 1, 1, 1, 8, 1, 4):
                with T.block("Y"):
                    v_mm = T.axis.spatial(32, mm_0 * 16 + mm_1 * 16 + mm_2 * 8 + mm_3)
                    v_bb = T.axis.spatial(30, bb_0 * 3 + bb_1 + bb_2 + bb_3)
                    v_rr = T.axis.spatial(128, rr_0 * 16 + rr_1 * 4 + rr_2 * 4 + rr_3)
                    v_rn = T.axis.reduce(32, rn_0 + rn_1)
                    v_rk = T.axis.reduce(32, rk_0 + rk_1)
                    T.reads(G[v_rr, v_rn, v_mm, v_rk], X[v_bb, v_rn, v_rk])
                    T.writes(Y[v_mm, v_bb, v_rr])
                    T.block_attr({"meta_schedule.tiling_structure": "SSRSRS"})
                    with T.init():
                        Y[v_mm, v_bb, v_rr] = T.float32(0.0)
                    Y[v_mm, v_bb, v_rr] = Y[v_mm, v_bb, v_rr] + G[v_rr, v_rn, v_mm, v_rk] * X[v_bb, v_rn, v_rk]
b0 = sch.get_block(name="Y", func_name="main")
b1 = sch.get_block(name="root", func_name="main")
sch.annotate(block_or_loop=b0, ann_key="meta_schedule.tiling_structure", ann_val="SSRSRS")
l2, l3, l4, l5, l6 = sch.get_loops(block=b0)
v7, v8, v9, v10 = sch.sample_perfect_tile(loop=l2, n=4, max_innermost_factor=64, decision=[2, 1, 2, 8])
l11, l12, l13, l14 = sch.split(loop=l2, factors=[v7, v8, v9, v10], preserve_unit_iters=True, disable_predication=False)
v15, v16, v17, v18 = sch.sample_perfect_tile(loop=l3, n=4, max_innermost_factor=64, decision=[10, 3, 1, 1])
l19, l20, l21, l22 = sch.split(loop=l3, factors=[v15, v16, v17, v18], preserve_unit_iters=True, disable_predication=False)
v23, v24, v25, v26 = sch.sample_perfect_tile(loop=l4, n=4, max_innermost_factor=64, decision=[8, 4, 1, 4])
l27, l28, l29, l30 = sch.split(loop=l4, factors=[v23, v24, v25, v26], preserve_unit_iters=True, disable_predication=False)
v31, v32 = sch.sample_perfect_tile(loop=l5, n=2, max_innermost_factor=64, decision=[32, 1])
l33, l34 = sch.split(loop=l5, factors=[v31, v32], preserve_unit_iters=True, disable_predication=False)
v35, v36 = sch.sample_perfect_tile(loop=l6, n=2, max_innermost_factor=64, decision=[32, 1])
l37, l38 = sch.split(loop=l6, factors=[v35, v36], preserve_unit_iters=True, disable_predication=False)
sch.reorder(l11, l19, l27, l12, l20, l28, l33, l37, l13, l21, l29, l34, l38, l14, l22, l30)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.parallel", ann_val=64)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.vectorize", ann_val=64)
v39 = sch.sample_categorical(candidates=[0, 16, 64, 512], probs=[0.25, 0.25, 0.25, 0.25], decision=1)
sch.annotate(block_or_loop=b1, ann_key="meta_schedule.unroll_explicit", ann_val=v39)
2025-07-03 10:24:11 [INFO] [task_scheduler.cc:137] [Task #0: main] Trial #1: GFLOPs: 39.6178. Time: 6352.1521 us. Best GFLOPs: 39.6178
